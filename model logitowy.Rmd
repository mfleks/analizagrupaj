---
title: "ANALIZA DANYCH-PROJEKT"
author: "Fleks, Dudanowicz, Kowalski"
date: "`r Sys.Date()`"
output:
  rmdformats::downcute:
    self_contained: true
    default_style: "light"
    downcute_theme: "default"
---

```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
#biblioteki
library(dplyr) 
library(ggplot2)
library(summarytools)
library(validate)
library(validatetools)
library(dcmodify)
library(errorlocate)
library(deductive)
library(VIM)
library(simputation)
library(lumberjack)
library(ISLR) 
library(xts)
library(quantmod)
library(ROCR)
library(DMwR)
library(Information)
library(scorecard)
library(editrules)
library(VIM)
library(deducorrect)
library(ISLR) 
library(janitor)
library(naniar)
library(mice)
library(editrules)
library(DMwR2)
library(outliers)
library(moments)
library(classInt)
library(corrplot)
library(mlogit)
library(mfx)
```

```{r}
#Na poczatku wczytujemy zbior danych
rowery<-read_excel("sklep_rowerowy.xlsx")
rowery<- sklep_rowerowy
```

# **SKLEP ROWEROWY**

Zbiór danych zawiera informacje na temat klientów sklepu rowerowego. Z jego pomocą możemy uzyskać informacje na temat wieku, dochodu, płci, liczby posiadanych dzieci czy regionu. Celem projektu jest przeprowadzenie kompleksowej analizy danych, która obejmować będzie kilka kluczowych etapów, a mianowicie: czyszczenie danych, wizualizację, analizę opisową i wnioskowanie statystyczne. 


## I ETAP - CZYSZCZENIE DANYCH

### 1. Przegląd danych

Obserwujemy m.in spacje na nazwach kolumn naszych zmiennych. Aby się ich pozbyć korzystamy z funkcji clean_names z pakietu 'janitor', która służy do przekształcania nazw kolumn w ramce danych w formę bardziej czytelną i zgodą z konwencją.

```{r}
head(rowery) #obserwujemy np.spacje w nazwach kolumn, aby sie ich pozbyc uzywamy funkcji clean_names
rowery <- clean_names(rowery) 
```

#### 1. Sprawdzenie występowania brakujących obserwacji NA

Poniżej przeprowadzona została analiza wartości brakujących NA dla poszczególnych zmiennych. Wskazano zarówno liczbę wierszy, w których występują braki, jak i konkretne ich numery.W ten sposób wiemy np., że zmienna "home_owner" ma 4 braki i występują one w wierszach: 7, 366, 647 i 944. Przedstawiono również wizualizację wartości brakujących.   

```{r}
sum(complete.cases(rowery)) #952 pełnych wierszy, czyli mamy 48 wierszy, w ktorych sa braki
manyNAs(rowery) #689 wiersz zawiera najwiecej brakow
sum(is.na(rowery)) #w sumie wystepuja 53 braki
miss_var_summary(rowery) #widzimy, że braki wystepuja jedynie dla zmiennych gender (11), cars(9),children (8), age(8), marital_status(7), income(6) i home_owner(4). Pozostale zmienne nie posiadaja zadnych wartosci brakujacych
rowery %>% 
  miss_case_table() #mamy 44 wiersze, w ktorych brak jest jednej wartosci, 3 wiersz z 2 brakami i jeden wiersz z 3 wartosciami NA
md.pattern(rowery) #wykres do zilustrowania brakow kazdej zmiennej
which(is.na(rowery$gender)) #4, 155, 336, 602, 689, 696, 868, 909, 952, 974, 998- numery wierszy, w ktorych sa braki dla zmiennej gender
which(is.na(rowery$cars)) #13, 197, 203, 352, 449, 512, 562, 616, 934-numery wierszy, w ktorych sa braki dla zmiennej cars
which(is.na(rowery$children)) #118, 218, 387, 550, 639, 689, 806, 961- numery wierszy, w ktorych sa braki dla zmiennej children
which(is.na(rowery$age)) #10,  99, 226, 372, 555, 689, 771, 987-numery wierszy, w ktorych sa braki dla zmiennej age
which(is.na(rowery$marital_status)) #9,  28,  50,  99, 151, 235, 302-numery wierszy, w ktorych sa braki dla zmiennej marital_status
which(is.na(rowery$income)) #10, 111, 192, 302, 442, 510-numery wierszy, w ktorych sa braki dla zmiennej income
which(is.na(rowery$home_owner)) #7, 366, 647, 944-numery wierszy, w ktorych sa braki dla zmiennej home_owner
```

#### 2. Sprawdzenie typów danych w każdej kolumnie

```{r}
data_class <- data.frame(class = sapply(rowery, class))
data_class
```

#### 3. Sprawdzenie wiarygodności danych

Poprzez wywołanie podstawowych statystyk możemy sprawdzić, czy nasze dane wydają się być wiarygodne, tzn. czy średnia ilość posiadanych dzieci, czy samochodów wydaje się być prawdopodobna. Ponadto użycie 'view(dfSummary(dane))' dostarcza nam wielu cennych informacji m.in.:
-widzimy, że każdy klient posiada unikalne id,
-otrzymujemy podsumowanie braków obserwacji dla każdej zmiennej,
-dla zmiennych jakościowych widzimy możliwe kategorie wyboru wraz z informacją o częstości jej wystąpienia.

```{r}
summary(rowery)
view(dfSummary(rowery))
descr(rowery)
```

#### 4. Sprawdzanie spełnienia pewnych reguł dla zbioru danych

Posiadając już podstawową wiedzę na temat naszych danych, chcemy sprawdzić kilka podstawowych reguł:
-czy zmienna wiek na pewno wszędzie przyjmuje wartości dodatnie,
-czy liczba posidanych dzieci nie jest nigdzie ujemna,
-czy liczba posiadanych samochodów nie jest ujemna,
-czy płeć przyjmuje jedną z dwóch kategorii 'kobieta' i 'mężczyna'

```{r}
rules <- validator(age > 0, gender %in% c('Female','Male')
                  , income >= 0, children >= 0, cars >= 0)
cf <- confront(rowery, rules, key="id")
summary(cf)
barplot(cf, main="rowery") #wizualizacja spełnienia reguły
#as.data.frame(cf) %>% head()

#Inny sposob
RULE <- editset(c("age > 0","gender %in% c('Female','Male')"
                  , "income >= 0", "children >= 0", "cars >= 0"))
RULE

summary(violatedEdits(RULE, rowery))
#rowery[localizeErrors(RULE, rowery)$adapt] <- NA -> w razie niespelnienia ktores z regul wartosci zmieniamy na NA

#Reguły w naszym zbiorze danych są spełnione!

```

### 2. Imputacja danych

Jak wynikało z analiz przeprowadzonych powyżej, w naszym zbiorze danych zlokalizowano 53 braki danych. Podjęto decyzję o nieusuwaniu żadnego z wierszy i uzupełnieniu wartości NA za pomocą różnych metod. 

#### 1. Imputacja-zmienne ilościowe

Braki w zmiennych dotyczących dochodu, wieku, liczby posidanych dzieci i samochodów wypełnione zostaną za pomocą średniej. Ze względu na specyfikę danych age, children i cars, wartości te nie powinny mieć żadnych miejsc po przecinku, gdyż nie możemy posiadać np. 1.5 dziecka. 

```{r}
rowery %>% filter(is.na(income)) %>% head
rowery[is.na(rowery$income), "income"] <- mean(rowery$income, na.rm = T)

# Inny sposob
#dochod<-imputate_na(rowery, income, method = "mean")
#summary(dochod)
#plot(dochod)

rowery %>% filter(is.na(age)) %>% head
rowery[is.na(rowery$age), "age"] <- round(mean(rowery$age, na.rm = T), digits=0)

rowery %>% filter(is.na(cars)) %>% head
rowery[is.na(rowery$cars), "cars"] <- round(mean(rowery$cars, na.rm = T), digits=0)

rowery %>% filter(is.na(children)) %>% head
rowery[is.na(rowery$children), "children"] <- round(mean(rowery$children, na.rm = T), digits=0)
```

#### 2. Imputacja-zmienne jakościowe

Po uzupełnieniu braków w zmiennych ilościowych, przystępujemy teraz do korekty brakujących danych w przypadku zmiennych jakościowych. Ponieważ nasze zmienne jakościowe zawierają jedynie dwie kategorie, planujemy zidentyfikować, która z tych kategorii jest dominująca. Następnie, braki danych w tych zmiennych zostaną wypełnione wartościami dominującymi, aby zachować spójność i ułatwić analizę danych.

```{r}
unique(rowery$home_owner) # dwie kategorie- tak i nie
unique(rowery$marital_status) # dwie kategorie- zamezny i singiel
unique(rowery$gender) # dwie kategorie- kobieta i mezczyzna

mice_plot <-aggr(rowery, col=c('navyblue', 'yellow'),numbers=TRUE, sortVars=TRUE, labels=names(rowery), cex.axis=7, ylab=c("Histogram of missing data","Pattern")) #wykres obrazujacy braki danych

#uzupelnianie danych dominanta
rowery[is.na(rowery$home_owner), "home_owner"] <- "Yes" #68,5% klientow posiada dom, jest to wiekszosc, wiec braki w danych uzupelniamy wartosci 'Yes'
rowery[is.na(rowery$marital_status), "marital_status"] <- "Married" #53,9% klientow posiada meza/zone, wiec braki w danych uzupelniamy wartoscia 'Married'
rowery[is.na(rowery$gender), "gender"] <- "Male" #50,6% klientow to mezczyznki, wiec braki w danych uzupelniamy wartoscia 'Male'

view(dfSummary(rowery)) #Wywolujemy tabelke podsumowujaca nasze dane. Widzimy, ze wszystkie dane zostaly uzupelnione.

```

### 3. Obserwacje odstające 

Sprawdzanie zbioru danych pod kątem wartości odstających jest kluczowe dla utrzymania jakości analizy danych i poprawnego zrozumienia badanego zjawiska. W przypadku identyfikacji wartości odstających, istnieją różne metody ich obsługi, takie jak usuwanie, transformacja, czy stosowanie bardziej zaawansowanych technik modelowania.
Przechodzimy więc do sprawdzenia naszego zbioru danych pod względem występowania wartości odstających.

#### 1. Zlokalizowanie wartości odstających

```{r}
#mozemy stworzyc np. funkcje, ktora bedzie wykrywac odstajace obserwacje
find_outliers <- function(rowery, k = 1.5) {
quantiles <- quantile(rowery, c(0.25, 0.5, 0.75))
diff <- k * (quantiles[3] - quantiles[1])
lb <- quantiles[1] - diff 
ub <- quantiles[3] + diff
  
is_outlier <- function(el) {
    el < lb || ub < el  
  }}
#BOXPLOT
boxplot.stats(rowery$income)$out #mamy 10 wartosci odstajacych dla zmiennej income
#TEST
test <- grubbs.test(rowery$income)
test #test Grubba'a potwierdza, ze najwyzsza wartosc 170 000 jest odstajaca
test1 <- grubbs.test(rowery$income, opposite = TRUE)
test1 #najmniejsza wartosc nie jest odstajaca
#WYKRES
boxplot(rowery$income, col = "blue",
  ylab = "income",
  main = "Boxplot of income")
mtext(paste("Outliers: ", paste(out, collapse = ", "))) #mozemy zwizualizowac wartosci odstajacae na wykresie wraz z opisem, ktore z nich sa odstajace

#sprawdzmy jeszcze wystepowanie wartosci odstajacych dla zmiennej age
boxplot.stats(rowery$age)$out #mamy 4 wartosci odstajace dla age
test <- grubbs.test(rowery$age)
test #uzyskana wartosc p-value testu potwierdza, ze najwyzsza wartosc 89 jest odstajaca
```

#### 4. Przekształcenie wartości odstających

Zdecydowano się przekształcić wartości odstające dla zmiennych "age" i "income" za pomocą metody capping.Metoda capping polega na ustaleniu górnej (max) i dolnej (min) granicy wartości dla danej zmiennej, a następnie przypisanie wszystkim wartościom przekraczającym te granice wartości skrajnych.  

```{r}
#income
qnt <- quantile(rowery$income, probs=c(.25, .75), na.rm = T)
caps <- quantile(rowery$income, probs=c(.05, .95), na.rm = T)
H <- 1.5 * IQR(rowery$income, na.rm = T)
rowery$income[rowery$income < (qnt[1] - H)] <- caps[1]
rowery$income[rowery$income > (qnt[2] + H)] <- caps[2]
boxplot.stats(rowery$income)$out #brak wartosci odstajacych dla income

#age
qnt <- quantile(rowery$age, probs=c(.25, .75), na.rm = T)
caps <- quantile(rowery$age, probs=c(.05, .95), na.rm = T)
H <- 1.5 * IQR(rowery$age, na.rm = T)
rowery$age[rowery$age < (qnt[1] - H)] <- caps[1]
rowery$age[rowery$age > (qnt[2] + H)] <- caps[2]
boxplot.stats(rowery$age)$out #brak wartosci odstajacych dla age

```

## II ETAP-WIZUALIZACJE

Wizualizacje stanowią potężne narzędzie w każdym projekcie, wspomagając efektywną komunikację, lepsze zrozumienie danych oraz sprzyjając szybszemu i bardziej kreatywnemu podejmowaniu decyzji.Poniżej przedstawiono kilka ciekawych wizualizacji dla analizowanego zbioru danych. 

### 1.Średni dochód w zależności od wieku i płci

```{r}
dw1<-rowery%>%
  group_by(age, gender)%>%
  summarize(meaninc=mean(income))
ggplot(dw1, aes(age, meaninc))+
  geom_line()+
  geom_point(colour="red")+
  facet_wrap(~gender)+
  labs(x="Wiek", y="Średnie dochody")
ggplot(dw1, aes(age, meaninc))+
  geom_line()+
  geom_point(colour="red")+
  facet_wrap(~gender)+labs(x="Wiek", y="Średnie dochody")+geom_smooth(method="lm")+ggtitle("Średni dochód w zależności od wieku oraz płci")
```

### 2. Występowanie obserwacji o określonym wieku i dochodzie

```{r}
ggplot(rowery, aes(age, income))+
  stat_sum(alpha=0.4)+
  scale_size(range=c(1,5))+
  ggtitle("Występowanie obserwacji o określonym wieku oraz poziomie dochodów")+labs(x="Wiek", y="Dochód", size="Występowanie")
```

### 3. Ilość posidanych samochodów w zależności od regionu

```{r}
ggplot(rowery, aes(x=cars, fill=region))+
  geom_bar(position="dodge")+
  labs(x="Ilość posiadanych samochodów", y="Występowanie", fill="Region")
```

### 4.Zagęszczenie obserwacji o określonym wieku w zależności od regionu

```{r}
ggplot(rowery, aes(age, fill=region))+
  geom_density(alpha=0.25)+
  labs(x="Wiek",y="Zagęszczenie", fill="Region")+
  ggtitle("Zagęszczenie obserwacji o określonym poziomie wieku w zależności od regionu")
```

### 5. Obserwacje o określonym poziomie dochodów w zależności od rodzaju zawodu

```{r}
ggplot(rowery, aes(income, fill=occupation))+
  geom_histogram(bins=20, color='black')+
  facet_wrap(~occupation, nrow=5)+
  labs(x="Dochód", y="Występowanie", fill="Praca")+
  theme(legend.position = 'none')+
  ggtitle("Wystepowanie obserwacji o określonym poziomie dochodów w zależności od rodzaju zawodu")
```

### 6. Wizualizacja poziomu dochodu w zależności od płci

```{r}
ggplot(rowery, aes(income, fill=occupation))+
  geom_histogram(bins=20)+
  facet_wrap(~occupation, nrow=5)+
  labs(x="Dochód", y="Występowanie", fill="Praca")+
  theme(legend.position = 'none')
ggplot(rowery, aes(gender, income))+
  geom_boxplot(aes(fill=gender))+
  stat_boxplot(geom="errorbar",position="dodge")+
  stat_summary(aes(ymin=after_stat(y),ymax=after_stat(y)),fun=mean)+ggtitle("Mediana dochodów, maksymalny, minimalny oraz średni dochód w zależności od płci")+theme(legend.position='none')
```

### 7. Ilość posiadanych samochodów w zależności od posiadania roweru

```{r}
ggplot(rowery, aes(occupation, fill=occupation))+geom_bar()+facet_wrap(~education, nrow=5)+labs(x="Zatrudnienie", y="Występowanie")+theme(legend.position= 'none')
ggplot(rowery, aes(cars, fill=purchased_bike))+geom_histogram(bins=5, position="dodge", color='black')+facet_wrap(~purchased_bike)+theme(legend.position='none')+labs(x="Ilość posiadanych samochodów", y="Występowanie")+ggtitle("Ilość posiadanych samochodów w zależności od posiadania roweru")
```

### 8. Ilość posiadanych samochodów w zależności od posiadania roweru

```{r}
ggplot(rowery, aes(marital_status, age))+
  geom_boxplot(aes(fill=marital_status))+
  stat_boxplot(geom="errorbar", position="dodge")+
  stat_summary(aes(ymin=..y..,ymax=..y..), fun=mean)
ggplot(rowery, aes(occupation, fill=occupation))+
  geom_bar(color='black')+
  facet_wrap(~education, nrow=5)+
  labs(x="Zatrudnienie", y="Występowanie")+
  theme(legend.position= 'none')+
  ggtitle("Występowanie obserwacji o poszczególnym rodzaju wykonywanej pracy według wykształcenia")
```

### 9. Średni dochód według wykształcenia oraz rodzaju pracy

```{r}
ggplot(rowery, aes(occupation, education, fill=income))+
  geom_tile(color='black')+
  scale_fill_gradient2(low="white", mid="yellow", high="red")+
  ggtitle("Średni dochód według wykształcenia oraz rodzaju pracy")
```

### 10. Analiza wieku według stanu cywilnego

```{r}
ggplot(rowery, aes(gender, income)) +
  geom_boxplot(aes(fill=gender))+
  stat_boxplot(geom="errorbar", position="dodge")+stat_summary(aes(ymin=..y..,ymax=..y..),fun=mean)
ggplot(rowery, aes(marital_status, age))+
  geom_boxplot(aes(fill=marital_status))+
  stat_boxplot(geom="errorbar", position="dodge")+
  stat_summary(aes(ymin=..y..,ymax=..y..), fun=mean)+
  labs(x="Stan cywilny", y="Wiek")+
  theme(legend.position='none')+
  ggtitle("Mediana, maksimum, minimum oraz średnia wieku według stanu cywilnego")
```

## III ETAP-ANALIZA OPISOWA

Analiza opisowa jest nieodzownym elementem każdego projektu. Dostarcza podstawowych informacji, które stanowią punkt wyjścia do bardziej zaawansowanych analiz statystycznych i pomagają zrozumieć istotę danych.

### 1. Tabele liczebności

W pierwszym etapie naszej analizy pogrupujemy nasze dane w postaci prostej tabeli częstości.Napotykamy tutaj jednak pewne problemy. Przykładowo zmienna 'income' jest zmienną ciągłą. Dokonamy więc diskretyzacji danych-przekształcimy zmienną ciągłą na zmienną dyskretną poprzez podział zakresu wartości na przedziały.

#### 1.Zmienna ciągła 'income'

```{r}
etykiety1<-c("0-25 000", "25 000-50 000", "50 000-75 000", "75 000-100 000", "100 000-125 000", "125 000-150 000")
limits1<-cut(rowery$income,seq(0,150000,by=25000),labels=etykiety1)
tabela2<-freq(limits1,type="html")
tabela2
tab1<-classIntervals(rowery$income,n=6,style="fixed",fixedBreaks=seq(0,150000,by=25000))
tab1
jenks.tests(tab1)
#wizualnie
hist(rowery$income, breaks="FD", col="green", probability = TRUE,
     main="INCOME")
```

Wskaźnik TAI jest bardzo wysoki, wiec możemy zaakceptować konstrukcję tabeli częstości.

#### 2. Zmienna dyskretna 'age'

```{r}
etykiety<-c("20-30 lat","30-40 lat","40-50 lat","50-60 lat","60-70 lat","70-80 lat")
limits<-cut(rowery$age,seq(20,80,by=10),labels=etykiety)
tabela1<-freq(limits,type="html")
tabela1
tab2<-classIntervals(rowery$age,n=6,style="fixed",fixedBreaks=seq(20,80,by=10))
tab2
jenks.tests(tab2)
# wizualnie
ggplot(rowery, aes(x = age)) +
  geom_histogram(binwidth = 2, fill = "blue", color = "red", alpha = 0.8) +
  labs(title = "Age Distribution", x = "Age", y = "Frequency")
```

Wskaźnik TAI jest dosyć wysoki, więc możemy zaakceptować konstrukcję tabeli częstości.

#### 3. Pozostałe tabele liczebności

```{r}
# EDUCATION
ggplot(rowery, aes(x = factor(education), fill = factor(education))) +
  geom_bar() +
  labs(title = "Education Distribution", x = "Education Level", y = "Count") +
  theme_minimal()

# REGION
ggplot(rowery, aes(x = factor(region), fill = factor(region))) +
  geom_bar() +
  labs(title = "Region Distribution", x = "Region", y = "Count") +
  theme_minimal()

# liczebnosc pozostaych zmiennych (zarowno liczbowa, jak i procentowa mozemy odczytac z tabelki)
dfSummary(view(rowery)) 
```

### 2. Podstawowe statystyki opisowe

Kolejnym etapem będzie przedstawienie podstawowych statystyk opisowych dla zmiennych ilościowych za pomocą zbiorczej tabelki.

```{r}
descr(rowery)
```

### 3. Korelacja 

Poniżej przedstawiona została korelacja pomiędzy zmiennymi ilościowymi.

```{r}
cor((rowery[,c(4,5,9,12)]), method="pearson")
corrplot(cor(rowery[,c(4,5,9,12)]), method = "number", type = "upper", diag =FALSE)
corr_matrix<-cor(rowery[,c(4,5,9,12)])
corrplot(corr_matrix, method="color")
```

## IV ETAP- WNIOSKOWANIE STATYSTYCZNE

Testowanie hipotez opiera się na założeniu pewnych warunków w populacji, a następnie analizie próby w celu zweryfikowania, czy dane założenie jest prawdziwe. Statystyki testowe i wartości p-value dostarczają nam narzędzi do dokładnego zrozumienia, czy obserwowane różnice między grupami czy parametrami są statystycznie istotne.

### Pytania badawcze

-Czy wartość dochodu jest zależna od regionu?
-Czy poziom wykształcenia na wpływ na poziom dochodu?
-Czy w małżeństwach rodzi się wiecej dzieci?
-Czy mężczyźni więcej zarabiają? 
-Czy osoby, które nie posiadają samochodu częściej kupują rowery?
-Czy osoby, które posiadają domy częściej kupują rowery? 



###     Model logitowy

Dla zmiennej 'purchased_bike' postanowiono stworzyć model logitowy, który ma za zadanie sprawdzić, jaki wpływ mają poszczególne zmienne na fakt, że klient zdecydował się na kupno roweru. Zmienna 'purchased_bike' jest jakościowa i przyjmuje dwie kategorie 'Yes' oraz 'No'. Za pomocą model.matrix zmienna ta została przekodowana tak, aby miała postać binarną, czyli przyjmowała tylko dwie wartości 0 dla 'No' i 1 dla 'Yes'. Zmienne o największej wartości p-value były stopniowo usuwane z początkowego modelu zgodnie z metodą a posteriori, tak, aby otrzymać ostateczny model końcowy- model7.

```{r}
df <- data.frame(rowery$purchased_bike = c("No", "Yes"))
encoded_data <- model.matrix(~purchased_bike - 1, data = rowery)

model= glm(encoded_data ~ gender + marital_status + region + cars + income + age + occupation + education + home_owner + commute_distance, family = binomial, data=rowery)
summary(model)

model2= glm(encoded_data ~ gender + marital_status + region + cars + income + age + occupation + education + home_owner, family = binomial, data=rowery)
summary(model2)

model3= glm(encoded_data ~ marital_status + region + cars + income + age + occupation + education + home_owner, family = binomial, data=rowery)
summary(model3)

model4= glm(encoded_data ~ marital_status + region + cars + income + age + education + home_owner, family = binomial, data=rowery)
summary(model4)

model5= glm(encoded_data ~ marital_status + region + cars + income + age  + home_owner, family = binomial, data=rowery)
summary(model5)

model6= glm(encoded_data ~ marital_status + region + cars + income + age, family = binomial, data=rowery)
summary(model6)

model7= glm(encoded_data ~ marital_status  + cars + income + age, family = binomial, data=rowery)
summary(model7)

#Liczymy iloraz szans, aby otrzymac wartosci do interpretacji
OR=exp(model7$coefficients)
OR
```










































